import {
  classAdderBuilder
} from "./chunk-HINFHKF4.js";
import "./chunk-5LS6UT5C.js";
import {
  MDCDialogFoundation,
  util_exports
} from "./chunk-JGPQ5NGG.js";
import "./chunk-ITX67HHZ.js";
import "./chunk-PPDJHPVW.js";
import "./chunk-P5HUA7KP.js";
import {
  focus_trap_exports
} from "./chunk-GPDONVQB.js";
import "./chunk-DAJP6YLI.js";
import {
  ponyfill_exports
} from "./chunk-E5B5ZADN.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-TVWPCQME.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-W54PNBU6.js";
import {
  writable
} from "./chunk-ZJLUEPEN.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_update,
  globals,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_store_value,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-HPG2YY3T.js";
import "./chunk-2AFTNLNW.js";
import "./chunk-25V3TAZK.js";

// node_modules/@smui/dialog/dist/Dialog.svelte
var { document: document_1, window: window_1 } = globals;
var file = "node_modules\\@smui\\dialog\\dist\\Dialog.svelte";
var get_over_slot_changes = (dirty) => ({});
var get_over_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let div;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-dialog__surface-scrim");
      add_location(div, file, 49, 8, 1397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "transitionend",
          /*transitionend_handler*/
          ctx[32],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(49:6) {#if fullscreen}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t0;
  let div3;
  let div1;
  let div0;
  let t1;
  let div0_class_value;
  let div1_class_value;
  let t2;
  let div2;
  let div3_class_value;
  let useActions_action;
  let forwardEvents_action;
  let t3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[29].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    null
  );
  let if_block = (
    /*fullscreen*/
    ctx[5] && create_if_block(ctx)
  );
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [
          /*surface$class*/
          ctx[9]
        ]: true,
        "mdc-dialog__surface": true
      })
    },
    { role: "alertdialog" },
    { "aria-modal": "true" },
    prefixFilter(
      /*$$restProps*/
      ctx[19],
      "surface$"
    )
  ];
  let div_data_1 = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div0_levels[i]);
  }
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [
          /*container$class*/
          ctx[8]
        ]: true,
        "mdc-dialog__container": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[19],
      "container$"
    )
  ];
  let div_data_2 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div1_levels[i]);
  }
  let div3_levels = [
    {
      class: div3_class_value = classMap({
        [
          /*className*/
          ctx[2]
        ]: true,
        "mdc-dialog": true,
        "mdc-dialog--stacked": !/*autoStackButtons*/
        ctx[4],
        "mdc-dialog--fullscreen": (
          /*fullscreen*/
          ctx[5]
        ),
        "mdc-dialog--sheet": (
          /*sheet*/
          ctx[6]
        ),
        "mdc-dialog--no-content-padding": (
          /*noContentPadding*/
          ctx[7]
        ),
        "smui-dialog--selection": (
          /*selection*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[12]
      })
    },
    { role: "alertdialog" },
    { "aria-modal": "true" },
    exclude(
      /*$$restProps*/
      ctx[19],
      ["container$", "surface$"]
    )
  ];
  let div_data_3 = {};
  for (let i = 0; i < div3_levels.length; i += 1) {
    div_data_3 = assign(div_data_3, div3_levels[i]);
  }
  const over_slot_template = (
    /*#slots*/
    ctx[29].over
  );
  const over_slot = create_slot(
    over_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_over_slot_context
  );
  const block = {
    c: function create() {
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      div2 = element("div");
      t3 = space();
      if (over_slot)
        over_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      t0 = claim_space(nodes);
      div3 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-modal": true
      });
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        role: true,
        "aria-modal": true
      });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      children(div2).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (over_slot)
        over_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div_data_1);
      add_location(div0, file, 38, 4, 1140);
      set_attributes(div1, div_data_2);
      add_location(div1, file, 31, 2, 980);
      attr_dev(div2, "class", "mdc-dialog__scrim");
      add_location(div2, file, 57, 2, 1593);
      set_attributes(div3, div_data_3);
      add_location(div3, file, 8, 0, 235);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div2);
      ctx[33](div3);
      insert_hydration_dev(target, t3, anchor);
      if (over_slot) {
        over_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window_1,
            "resize",
            /*resize_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window_1,
            "orientationchange",
            /*orientationchange_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            document_1.body,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleDocumentKeydown.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleDocumentKeydown.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            div3,
            /*use*/
            ctx[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[13].call(null, div3)),
          listen_dev(
            div3,
            "SMUIDialog:opening",
            /*handleDialogOpening*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "SMUIDialog:opened",
            /*handleDialogOpened*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "SMUIDialog:closed",
            /*handleDialogClosed*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "click",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleClick.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleClick.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[10] && /*instance*/
                ctx[10].handleKeydown.bind(
                  /*instance*/
                  ctx[10]
                )
              ))
                /*instance*/
                (ctx[10] && /*instance*/
                ctx[10].handleKeydown.bind(
                  /*instance*/
                  ctx[10]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*fullscreen*/
        ctx[5]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div0, div_data_1 = get_spread_update(div0_levels, [
        (!current || dirty[0] & /*surface$class*/
        512 && div0_class_value !== (div0_class_value = classMap({
          [
            /*surface$class*/
            ctx[9]
          ]: true,
          "mdc-dialog__surface": true
        }))) && { class: div0_class_value },
        { role: "alertdialog" },
        { "aria-modal": "true" },
        dirty[0] & /*$$restProps*/
        524288 && prefixFilter(
          /*$$restProps*/
          ctx[19],
          "surface$"
        )
      ]));
      set_attributes(div1, div_data_2 = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*container$class*/
        256 && div1_class_value !== (div1_class_value = classMap({
          [
            /*container$class*/
            ctx[8]
          ]: true,
          "mdc-dialog__container": true
        }))) && { class: div1_class_value },
        dirty[0] & /*$$restProps*/
        524288 && prefixFilter(
          /*$$restProps*/
          ctx[19],
          "container$"
        )
      ]));
      set_attributes(div3, div_data_3 = get_spread_update(div3_levels, [
        (!current || dirty[0] & /*className, autoStackButtons, fullscreen, sheet, noContentPadding, selection, internalClasses*/
        4348 && div3_class_value !== (div3_class_value = classMap({
          [
            /*className*/
            ctx[2]
          ]: true,
          "mdc-dialog": true,
          "mdc-dialog--stacked": !/*autoStackButtons*/
          ctx[4],
          "mdc-dialog--fullscreen": (
            /*fullscreen*/
            ctx[5]
          ),
          "mdc-dialog--sheet": (
            /*sheet*/
            ctx[6]
          ),
          "mdc-dialog--no-content-padding": (
            /*noContentPadding*/
            ctx[7]
          ),
          "smui-dialog--selection": (
            /*selection*/
            ctx[3]
          ),
          .../*internalClasses*/
          ctx[12]
        }))) && { class: div3_class_value },
        { role: "alertdialog" },
        { "aria-modal": "true" },
        dirty[0] & /*$$restProps*/
        524288 && exclude(
          /*$$restProps*/
          ctx[19],
          ["container$", "surface$"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx[1]
        );
      if (over_slot) {
        if (over_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            over_slot,
            over_slot_template,
            ctx,
            /*$$scope*/
            ctx[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[28]
            ) : get_slot_changes(
              over_slot_template,
              /*$$scope*/
              ctx[28],
              dirty,
              get_over_slot_changes
            ),
            get_over_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(over_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(over_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div3);
        detach_dev(t3);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[33](null);
      if (over_slot)
        over_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "open",
    "selection",
    "escapeKeyAction",
    "scrimClickAction",
    "autoStackButtons",
    "fullscreen",
    "sheet",
    "noContentPadding",
    "container$class",
    "surface$class",
    "isOpen",
    "setOpen",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $aboveFullscreenShown;
  let $actionButtonsReversed;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dialog", slots, ["default", "over"]);
  var _a;
  const { FocusTrap } = focus_trap_exports;
  const { closest, matches } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { open = false } = $$props;
  let { selection = false } = $$props;
  let { escapeKeyAction = "close" } = $$props;
  let { scrimClickAction = "close" } = $$props;
  let { autoStackButtons = true } = $$props;
  let { fullscreen = false } = $$props;
  let { sheet = false } = $$props;
  let { noContentPadding = false } = $$props;
  let { container$class = "" } = $$props;
  let { surface$class = "" } = $$props;
  let element2;
  let instance;
  let internalClasses = {};
  let focusTrap;
  let actionButtonsReversed = writable(false);
  validate_store(actionButtonsReversed, "actionButtonsReversed");
  component_subscribe($$self, actionButtonsReversed, (value) => $$invalidate(37, $actionButtonsReversed = value));
  let aboveFullscreen = getContext("SMUI:dialog:aboveFullscreen");
  let aboveFullscreenShown = (_a = getContext("SMUI:dialog:aboveFullscreenShown")) !== null && _a !== void 0 ? _a : writable(false);
  validate_store(aboveFullscreenShown, "aboveFullscreenShown");
  component_subscribe($$self, aboveFullscreenShown, (value) => $$invalidate(27, $aboveFullscreenShown = value));
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let layoutListeners = [];
  let addLayoutListenerFn = (listener) => {
    layoutListeners.push(listener);
    return () => {
      const idx = layoutListeners.indexOf(listener);
      if (idx >= 0) {
        layoutListeners.splice(idx, 1);
      }
    };
  };
  setContext("SMUI:dialog:actions:reversed", actionButtonsReversed);
  setContext("SMUI:addLayoutListener", addLayoutListenerFn);
  setContext("SMUI:dialog:selection", selection);
  setContext("SMUI:dialog:aboveFullscreen", aboveFullscreen || fullscreen);
  setContext("SMUI:dialog:aboveFullscreenShown", aboveFullscreenShown);
  if (sheet) {
    setContext("SMUI:icon-button:context", "dialog:sheet");
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  let previousAboveFullscreenShown = $aboveFullscreenShown;
  onMount(() => {
    var _a2;
    focusTrap = new FocusTrap(
      element2,
      {
        initialFocusEl: (_a2 = getInitialFocusEl()) !== null && _a2 !== void 0 ? _a2 : void 0
      }
    );
    $$invalidate(10, instance = new MDCDialogFoundation({
      addBodyClass: (className2) => document.body.classList.add(className2),
      addClass,
      areButtonsStacked: () => util_exports.areTopsMisaligned(getButtonEls()),
      clickDefaultButton: () => {
        const defaultButton = getDefaultButtonEl();
        if (defaultButton) {
          defaultButton.click();
        }
      },
      eventTargetMatches: (target, selector) => target ? matches(target, selector) : false,
      getActionFromEvent: (evt) => {
        if (!evt.target) {
          return "";
        }
        const element3 = closest(evt.target, "[data-mdc-dialog-action]");
        return element3 && element3.getAttribute("data-mdc-dialog-action");
      },
      getInitialFocusEl,
      hasClass,
      isContentScrollable: () => util_exports.isScrollable(getContentEl()),
      notifyClosed: (action) => {
        $$invalidate(0, open = false);
        dispatch(getElement(), "SMUIDialog:closed", action ? { action } : {}, void 0, true);
      },
      notifyClosing: (action) => dispatch(getElement(), "SMUIDialog:closing", action ? { action } : {}, void 0, true),
      notifyOpened: () => dispatch(getElement(), "SMUIDialog:opened", {}, void 0, true),
      notifyOpening: () => dispatch(getElement(), "SMUIDialog:opening", {}, void 0, true),
      releaseFocus: () => focusTrap.releaseFocus(),
      removeBodyClass: (className2) => document.body.classList.remove(className2),
      removeClass,
      reverseButtons: () => {
        set_store_value(actionButtonsReversed, $actionButtonsReversed = true, $actionButtonsReversed);
      },
      trapFocus: () => focusTrap.trapFocus(),
      registerContentEventHandler: (evt, handler) => {
        const content = getContentEl();
        if (content instanceof HTMLElement) {
          content.addEventListener(evt, handler);
        }
      },
      deregisterContentEventHandler: (evt, handler) => {
        const content = getContentEl();
        if (content instanceof HTMLElement) {
          content.removeEventListener(evt, handler);
        }
      },
      isScrollableContentAtTop: () => {
        return util_exports.isScrollAtTop(getContentEl());
      },
      isScrollableContentAtBottom: () => {
        return util_exports.isScrollAtBottom(getContentEl());
      },
      registerWindowEventHandler: (evt, handler) => {
        window.addEventListener(evt, handler);
      },
      deregisterWindowEventHandler: (evt, handler) => {
        window.removeEventListener(evt, handler);
      }
    }));
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = false, internalClasses);
    }
  }
  function getButtonEls() {
    return [].slice.call(element2.querySelectorAll(".mdc-dialog__button"));
  }
  function getDefaultButtonEl() {
    return element2.querySelector("[data-mdc-dialog-button-default]");
  }
  function getContentEl() {
    return element2.querySelector(".mdc-dialog__content");
  }
  function getInitialFocusEl() {
    return element2.querySelector("[data-mdc-dialog-initial-focus]");
  }
  function handleDialogOpening() {
    if (aboveFullscreen) {
      set_store_value(aboveFullscreenShown, $aboveFullscreenShown = true, $aboveFullscreenShown);
    }
    requestAnimationFrame(() => {
      layoutListeners.forEach((listener) => listener());
    });
  }
  function handleDialogOpened() {
    layoutListeners.forEach((listener) => listener());
  }
  function handleDialogClosed() {
    if (aboveFullscreen) {
      set_store_value(aboveFullscreenShown, $aboveFullscreenShown = false, $aboveFullscreenShown);
    }
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(0, open = value);
  }
  function layout() {
    return instance.layout();
  }
  function getElement() {
    return element2;
  }
  const resize_handler = () => open && instance && instance.layout();
  const orientationchange_handler = () => open && instance && instance.layout();
  const transitionend_handler = () => instance && instance.handleSurfaceScrimTransitionEnd();
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(11, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("selection" in $$new_props)
      $$invalidate(3, selection = $$new_props.selection);
    if ("escapeKeyAction" in $$new_props)
      $$invalidate(20, escapeKeyAction = $$new_props.escapeKeyAction);
    if ("scrimClickAction" in $$new_props)
      $$invalidate(21, scrimClickAction = $$new_props.scrimClickAction);
    if ("autoStackButtons" in $$new_props)
      $$invalidate(4, autoStackButtons = $$new_props.autoStackButtons);
    if ("fullscreen" in $$new_props)
      $$invalidate(5, fullscreen = $$new_props.fullscreen);
    if ("sheet" in $$new_props)
      $$invalidate(6, sheet = $$new_props.sheet);
    if ("noContentPadding" in $$new_props)
      $$invalidate(7, noContentPadding = $$new_props.noContentPadding);
    if ("container$class" in $$new_props)
      $$invalidate(8, container$class = $$new_props.container$class);
    if ("surface$class" in $$new_props)
      $$invalidate(9, surface$class = $$new_props.surface$class);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCDialogFoundation,
    util: util_exports,
    domFocusTrap: focus_trap_exports,
    ponyfill: ponyfill_exports,
    onMount,
    onDestroy,
    getContext,
    setContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    FocusTrap,
    closest,
    matches,
    forwardEvents,
    use,
    className,
    open,
    selection,
    escapeKeyAction,
    scrimClickAction,
    autoStackButtons,
    fullscreen,
    sheet,
    noContentPadding,
    container$class,
    surface$class,
    element: element2,
    instance,
    internalClasses,
    focusTrap,
    actionButtonsReversed,
    aboveFullscreen,
    aboveFullscreenShown,
    addLayoutListener,
    removeLayoutListener,
    layoutListeners,
    addLayoutListenerFn,
    previousAboveFullscreenShown,
    hasClass,
    addClass,
    removeClass,
    getButtonEls,
    getDefaultButtonEl,
    getContentEl,
    getInitialFocusEl,
    handleDialogOpening,
    handleDialogOpened,
    handleDialogClosed,
    isOpen,
    setOpen,
    layout,
    getElement,
    $aboveFullscreenShown,
    $actionButtonsReversed
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("selection" in $$props)
      $$invalidate(3, selection = $$new_props.selection);
    if ("escapeKeyAction" in $$props)
      $$invalidate(20, escapeKeyAction = $$new_props.escapeKeyAction);
    if ("scrimClickAction" in $$props)
      $$invalidate(21, scrimClickAction = $$new_props.scrimClickAction);
    if ("autoStackButtons" in $$props)
      $$invalidate(4, autoStackButtons = $$new_props.autoStackButtons);
    if ("fullscreen" in $$props)
      $$invalidate(5, fullscreen = $$new_props.fullscreen);
    if ("sheet" in $$props)
      $$invalidate(6, sheet = $$new_props.sheet);
    if ("noContentPadding" in $$props)
      $$invalidate(7, noContentPadding = $$new_props.noContentPadding);
    if ("container$class" in $$props)
      $$invalidate(8, container$class = $$new_props.container$class);
    if ("surface$class" in $$props)
      $$invalidate(9, surface$class = $$new_props.surface$class);
    if ("element" in $$props)
      $$invalidate(11, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(10, instance = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(12, internalClasses = $$new_props.internalClasses);
    if ("focusTrap" in $$props)
      focusTrap = $$new_props.focusTrap;
    if ("actionButtonsReversed" in $$props)
      $$invalidate(14, actionButtonsReversed = $$new_props.actionButtonsReversed);
    if ("aboveFullscreen" in $$props)
      $$invalidate(41, aboveFullscreen = $$new_props.aboveFullscreen);
    if ("aboveFullscreenShown" in $$props)
      $$invalidate(15, aboveFullscreenShown = $$new_props.aboveFullscreenShown);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("layoutListeners" in $$props)
      layoutListeners = $$new_props.layoutListeners;
    if ("addLayoutListenerFn" in $$props)
      addLayoutListenerFn = $$new_props.addLayoutListenerFn;
    if ("previousAboveFullscreenShown" in $$props)
      $$invalidate(26, previousAboveFullscreenShown = $$new_props.previousAboveFullscreenShown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*instance, escapeKeyAction*/
    1049600) {
      $:
        if (instance && instance.getEscapeKeyAction() !== escapeKeyAction) {
          instance.setEscapeKeyAction(escapeKeyAction);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, scrimClickAction*/
    2098176) {
      $:
        if (instance && instance.getScrimClickAction() !== scrimClickAction) {
          instance.setScrimClickAction(scrimClickAction);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, autoStackButtons*/
    1040) {
      $:
        if (instance && instance.getAutoStackButtons() !== autoStackButtons) {
          instance.setAutoStackButtons(autoStackButtons);
        }
    }
    if ($$self.$$.dirty[0] & /*autoStackButtons*/
    16) {
      $:
        if (!autoStackButtons) {
          set_store_value(actionButtonsReversed, $actionButtonsReversed = true, $actionButtonsReversed);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, open*/
    1025) {
      $:
        if (instance && instance.isOpen() !== open) {
          if (open) {
            instance.open({
              isAboveFullscreenDialog: !!aboveFullscreen
            });
          } else {
            instance.close();
          }
        }
    }
    if ($$self.$$.dirty[0] & /*fullscreen, instance, previousAboveFullscreenShown, $aboveFullscreenShown*/
    201327648) {
      $:
        if (fullscreen && instance && previousAboveFullscreenShown !== $aboveFullscreenShown) {
          $$invalidate(26, previousAboveFullscreenShown = $aboveFullscreenShown);
          if ($aboveFullscreenShown) {
            instance.showSurfaceScrim();
          } else {
            instance.hideSurfaceScrim();
          }
        }
    }
  };
  return [
    open,
    use,
    className,
    selection,
    autoStackButtons,
    fullscreen,
    sheet,
    noContentPadding,
    container$class,
    surface$class,
    instance,
    element2,
    internalClasses,
    forwardEvents,
    actionButtonsReversed,
    aboveFullscreenShown,
    handleDialogOpening,
    handleDialogOpened,
    handleDialogClosed,
    $$restProps,
    escapeKeyAction,
    scrimClickAction,
    isOpen,
    setOpen,
    layout,
    getElement,
    previousAboveFullscreenShown,
    $aboveFullscreenShown,
    $$scope,
    slots,
    resize_handler,
    orientationchange_handler,
    transitionend_handler,
    div3_binding
  ];
}
var Dialog = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 1,
        class: 2,
        open: 0,
        selection: 3,
        escapeKeyAction: 20,
        scrimClickAction: 21,
        autoStackButtons: 4,
        fullscreen: 5,
        sheet: 6,
        noContentPadding: 7,
        container$class: 8,
        surface$class: 9,
        isOpen: 22,
        setOpen: 23,
        layout: 24,
        getElement: 25
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dialog",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get escapeKeyAction() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set escapeKeyAction(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrimClickAction() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrimClickAction(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoStackButtons() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoStackButtons(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullscreen() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullscreen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sheet() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sheet(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noContentPadding() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noContentPadding(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container$class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container$class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get surface$class() {
    throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set surface$class(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[22];
  }
  set isOpen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOpen() {
    return this.$$.ctx[23];
  }
  set setOpen(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[24];
  }
  set layout(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[25];
  }
  set getElement(value) {
    throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dialog_default = Dialog;

// node_modules/@smui/dialog/dist/Header.js
var Header_default = classAdderBuilder({
  class: "mdc-dialog__header",
  tag: "div",
  contexts: {
    "SMUI:icon-button:context": "dialog:header"
  }
});

// node_modules/@smui/dialog/dist/Title.js
var Title_default = classAdderBuilder({
  class: "mdc-dialog__title",
  tag: "h2"
});

// node_modules/@smui/dialog/dist/Content.js
var Content_default = classAdderBuilder({
  class: "mdc-dialog__content",
  tag: "div"
});

// node_modules/@smui/dialog/dist/Actions.js
var Actions_default = classAdderBuilder({
  class: "mdc-dialog__actions",
  tag: "div",
  classMap: {
    "smui-dialog__actions--reversed": "SMUI:dialog:actions:reversed"
  },
  contexts: {
    "SMUI:button:context": "dialog:action"
  }
});

// node_modules/@smui/dialog/dist/InitialFocus.js
function InitialFocus(node) {
  node.setAttribute("data-mdc-dialog-initial-focus", "");
  return {
    destroy() {
      node.removeAttribute("data-mdc-dialog-initial-focus");
    }
  };
}

// node_modules/@smui/dialog/dist/index.js
var dist_default = Dialog_default;
export {
  Actions_default as Actions,
  Content_default as Content,
  Header_default as Header,
  InitialFocus,
  Title_default as Title,
  dist_default as default
};
//# sourceMappingURL=@smui_dialog.js.map
