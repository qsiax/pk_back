import "./chunk-WTUOSYMF.js";
import {
  core_default
} from "./chunk-ZTPLTCA3.js";
import "./chunk-DHRKOMSH.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  afterUpdate,
  append_hydration_dev,
  assign,
  attr_dev,
  beforeUpdate,
  binding_callbacks,
  check_outros,
  children,
  claim_element,
  claim_space,
  compute_rest_props,
  createEventDispatcher,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  set_attributes,
  set_dynamic_element_data,
  space,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-PRJKVGTD.js";
import "./chunk-YFXSWJR3.js";
import "./chunk-W54PNBU6.js";
import "./chunk-2AFTNLNW.js";
import "./chunk-TYRVL62N.js";

// node_modules/swiper/components-shared/utils.js
function isObject(o) {
  return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function extend(target, src) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__)
        target[key] = src[key];
      else
        extend(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params = {}) {
  return params.navigation && typeof params.navigation.nextEl === "undefined" && typeof params.navigation.prevEl === "undefined";
}
function needsPagination(params = {}) {
  return params.pagination && typeof params.pagination.el === "undefined";
}
function needsScrollbar(params = {}) {
  return params.scrollbar && typeof params.scrollbar.el === "undefined";
}
function uniqueClasses(classNames = "") {
  const classes = classNames.split(" ").map((c) => c.trim()).filter((c) => !!c);
  const unique = [];
  classes.forEach((c) => {
    if (unique.indexOf(c) < 0)
      unique.push(c);
  });
  return unique.join(" ");
}

// node_modules/swiper/components-shared/params-list.js
var paramsList = [
  "modules",
  "init",
  "_direction",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_preloadImages",
  "updateOnImagesReady",
  "_loop",
  "_loopAdditionalSlides",
  "_loopedSlides",
  "_loopedSlidesLimit",
  "_loopFillGroupWithBlank",
  "loopPreventsSlide",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideBlankClass",
  "slideActiveClass",
  "slideDuplicateActiveClass",
  "slideVisibleClass",
  "slideDuplicateClass",
  "slideNextClass",
  "slideDuplicateNextClass",
  "slidePrevClass",
  "slideDuplicatePrevClass",
  "wrapperClass",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  // modules
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "lazy",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom"
];

// node_modules/swiper/components-shared/get-params.js
function getParams(obj = {}, splitEvents = true) {
  const params = {
    on: {}
  };
  const events = {};
  const passedParams = {};
  extend(params, core_default.defaults);
  extend(params, core_default.extendedDefaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map((key) => key.replace(/_/, ""));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach((key) => {
    if (typeof obj[key] === "undefined")
      return;
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend(params[key], obj[key]);
        extend(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === "function") {
      if (splitEvents) {
        events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      } else {
        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      }
    } else {
      rest[key] = obj[key];
    }
  });
  ["navigation", "pagination", "scrollbar"].forEach((key) => {
    if (params[key] === true)
      params[key] = {};
    if (params[key] === false)
      delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events
  };
}

// node_modules/swiper/components-shared/mount-swiper.js
function mountSwiper({
  el,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper.init(el);
}

// node_modules/swiper/components-shared/get-changed-params.js
function getChangedParams(swiperParams, oldParams, children2, oldChildren, getKey) {
  const keys = [];
  if (!oldParams)
    return keys;
  const addKey = (key) => {
    if (keys.indexOf(key) < 0)
      keys.push(key);
  };
  if (children2 && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children2.map(getKey);
    if (oldChildrenKeys.join("") !== childrenKeys.join(""))
      addKey("children");
    if (oldChildren.length !== children2.length)
      addKey("children");
  }
  const watchParams = paramsList.filter((key) => key[0] === "_").map((key) => key.replace(/_/, ""));
  watchParams.forEach((key) => {
    if (key in swiperParams && key in oldParams) {
      if (isObject(swiperParams[key]) && isObject(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach((newKey) => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach((oldKey) => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey])
              addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys;
}

// node_modules/swiper/components-shared/update-swiper.js
function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  scrollbarEl,
  paginationEl
}) {
  const updateParams = changedParams.filter((key) => key !== "children" && key !== "direction");
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = (mod) => {
    if (!swiper[mod])
      return;
    swiper[mod].destroy();
    if (mod === "navigation") {
      currentParams[mod].prevEl = void 0;
      currentParams[mod].nextEl = void 0;
      swiper[mod].prevEl = void 0;
      swiper[mod].nextEl = void 0;
    } else {
      currentParams[mod].el = void 0;
      swiper[mod].el = void 0;
    }
  };
  updateParams.forEach((key) => {
    if (isObject(currentParams[key]) && isObject(passedParams[key])) {
      extend(currentParams[key], passedParams[key]);
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === "navigation" || key === "pagination" || key === "scrollbar")) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes("controller") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes("children") && swiper.lazy && swiper.params.lazy.enabled) {
    swiper.lazy.load();
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized)
      thumbs.update(true);
  }
  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (paginationEl)
      currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (scrollbarEl)
      currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (nextEl)
      currentParams.navigation.nextEl = nextEl;
    if (prevEl)
      currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes("allowSlideNext")) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes("allowSlidePrev")) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes("direction")) {
    swiper.changeDirection(passedParams.direction, false);
  }
  swiper.update();
}

// node_modules/swiper/svelte/swiper.svelte
var file = "node_modules\\swiper\\svelte\\swiper.svelte";
var get_container_end_slot_changes = (dirty) => ({});
var get_container_end_slot_context = (ctx) => ({});
var get_wrapper_end_slot_changes = (dirty) => ({});
var get_wrapper_end_slot_context = (ctx) => ({});
var get_default_slot_changes = (dirty) => ({
  virtualData: dirty & /*virtualData*/
  2048
});
var get_default_slot_context = (ctx) => ({ virtualData: (
  /*virtualData*/
  ctx[11]
) });
var get_wrapper_start_slot_changes = (dirty) => ({});
var get_wrapper_start_slot_context = (ctx) => ({});
var get_container_start_slot_changes = (dirty) => ({});
var get_container_start_slot_context = (ctx) => ({});
function create_if_block_2(ctx) {
  let div0;
  let t;
  let div1;
  const block = {
    c: function create() {
      div0 = element("div");
      t = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "swiper-button-prev");
      add_location(div0, file, 166, 4, 4388);
      attr_dev(div1, "class", "swiper-button-next");
      add_location(div1, file, 167, 4, 4446);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      ctx[15](div0);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div1, anchor);
      ctx[16](div1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t);
        detach_dev(div1);
      }
      ctx[15](null);
      ctx[16](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(166:2) {#if needsNavigation(swiperParams)}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "swiper-scrollbar");
      add_location(div, file, 170, 4, 4549);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[17](div);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(170:2) {#if needsScrollbar(swiperParams)}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "swiper-pagination");
      add_location(div, file, 173, 4, 4656);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[18](div);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[18](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(173:2) {#if needsPagination(swiperParams)}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element1;
  let t0;
  let svelte_element0;
  let t1;
  let t2;
  let t3;
  let show_if_2 = needsNavigation(
    /*swiperParams*/
    ctx[4]
  );
  let t4;
  let show_if_1 = needsScrollbar(
    /*swiperParams*/
    ctx[4]
  );
  let t5;
  let show_if = needsPagination(
    /*swiperParams*/
    ctx[4]
  );
  let t6;
  let svelte_element1_class_value;
  let current;
  const container_start_slot_template = (
    /*#slots*/
    ctx[14]["container-start"]
  );
  const container_start_slot = create_slot(
    container_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_container_start_slot_context
  );
  const wrapper_start_slot_template = (
    /*#slots*/
    ctx[14]["wrapper-start"]
  );
  const wrapper_start_slot = create_slot(
    wrapper_start_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_wrapper_start_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_default_slot_context
  );
  const wrapper_end_slot_template = (
    /*#slots*/
    ctx[14]["wrapper-end"]
  );
  const wrapper_end_slot = create_slot(
    wrapper_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_wrapper_end_slot_context
  );
  let if_block0 = show_if_2 && create_if_block_2(ctx);
  let if_block1 = show_if_1 && create_if_block_1(ctx);
  let if_block2 = show_if && create_if_block(ctx);
  const container_end_slot_template = (
    /*#slots*/
    ctx[14]["container-end"]
  );
  const container_end_slot = create_slot(
    container_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_container_end_slot_context
  );
  let svelte_element1_levels = [
    {
      class: svelte_element1_class_value = uniqueClasses(`${/*containerClasses*/
      ctx[3]}${/*className*/
      ctx[0] ? ` ${/*className*/
      ctx[0]}` : ""}`)
    },
    /*restProps*/
    ctx[5]
  ];
  let svelte_element_data_1 = {};
  for (let i = 0; i < svelte_element1_levels.length; i += 1) {
    svelte_element_data_1 = assign(svelte_element_data_1, svelte_element1_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element1 = element(
        /*tag*/
        ctx[1]
      );
      if (container_start_slot)
        container_start_slot.c();
      t0 = space();
      svelte_element0 = element(
        /*wrapperTag*/
        ctx[2]
      );
      if (wrapper_start_slot)
        wrapper_start_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (wrapper_end_slot)
        wrapper_end_slot.c();
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      if (if_block2)
        if_block2.c();
      t6 = space();
      if (container_end_slot)
        container_end_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element1 = claim_element(
        nodes,
        /*tag*/
        (ctx[1] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element1_nodes = children(svelte_element1);
      if (container_start_slot)
        container_start_slot.l(svelte_element1_nodes);
      t0 = claim_space(svelte_element1_nodes);
      svelte_element0 = claim_element(
        svelte_element1_nodes,
        /*wrapperTag*/
        (ctx[2] || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element0_nodes = children(svelte_element0);
      if (wrapper_start_slot)
        wrapper_start_slot.l(svelte_element0_nodes);
      t1 = claim_space(svelte_element0_nodes);
      if (default_slot)
        default_slot.l(svelte_element0_nodes);
      t2 = claim_space(svelte_element0_nodes);
      if (wrapper_end_slot)
        wrapper_end_slot.l(svelte_element0_nodes);
      svelte_element0_nodes.forEach(detach_dev);
      t3 = claim_space(svelte_element1_nodes);
      if (if_block0)
        if_block0.l(svelte_element1_nodes);
      t4 = claim_space(svelte_element1_nodes);
      if (if_block1)
        if_block1.l(svelte_element1_nodes);
      t5 = claim_space(svelte_element1_nodes);
      if (if_block2)
        if_block2.l(svelte_element1_nodes);
      t6 = claim_space(svelte_element1_nodes);
      if (container_end_slot)
        container_end_slot.l(svelte_element1_nodes);
      svelte_element1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*wrapperTag*/
        ctx[2]
      )(svelte_element0, { class: "swiper-wrapper" });
      add_location(svelte_element0, file, 160, 2, 4175);
      set_dynamic_element_data(
        /*tag*/
        ctx[1]
      )(svelte_element1, svelte_element_data_1);
      add_location(svelte_element1, file, 153, 0, 3986);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element1, anchor);
      if (container_start_slot) {
        container_start_slot.m(svelte_element1, null);
      }
      append_hydration_dev(svelte_element1, t0);
      append_hydration_dev(svelte_element1, svelte_element0);
      if (wrapper_start_slot) {
        wrapper_start_slot.m(svelte_element0, null);
      }
      append_hydration_dev(svelte_element0, t1);
      if (default_slot) {
        default_slot.m(svelte_element0, null);
      }
      append_hydration_dev(svelte_element0, t2);
      if (wrapper_end_slot) {
        wrapper_end_slot.m(svelte_element0, null);
      }
      append_hydration_dev(svelte_element1, t3);
      if (if_block0)
        if_block0.m(svelte_element1, null);
      append_hydration_dev(svelte_element1, t4);
      if (if_block1)
        if_block1.m(svelte_element1, null);
      append_hydration_dev(svelte_element1, t5);
      if (if_block2)
        if_block2.m(svelte_element1, null);
      append_hydration_dev(svelte_element1, t6);
      if (container_end_slot) {
        container_end_slot.m(svelte_element1, null);
      }
      ctx[19](svelte_element1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (container_start_slot) {
        if (container_start_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            container_start_slot,
            container_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              container_start_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_container_start_slot_changes
            ),
            get_container_start_slot_context
          );
        }
      }
      if (wrapper_start_slot) {
        if (wrapper_start_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            wrapper_start_slot,
            wrapper_start_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              wrapper_start_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_wrapper_start_slot_changes
            ),
            get_wrapper_start_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, virtualData*/
        10240)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      if (wrapper_end_slot) {
        if (wrapper_end_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            wrapper_end_slot,
            wrapper_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              wrapper_end_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_wrapper_end_slot_changes
            ),
            get_wrapper_end_slot_context
          );
        }
      }
      if (dirty & /*swiperParams*/
      16)
        show_if_2 = needsNavigation(
          /*swiperParams*/
          ctx2[4]
        );
      if (show_if_2) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(svelte_element1, t4);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*swiperParams*/
      16)
        show_if_1 = needsScrollbar(
          /*swiperParams*/
          ctx2[4]
        );
      if (show_if_1) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          if_block1.m(svelte_element1, t5);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*swiperParams*/
      16)
        show_if = needsPagination(
          /*swiperParams*/
          ctx2[4]
        );
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          if_block2.m(svelte_element1, t6);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (container_end_slot) {
        if (container_end_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            container_end_slot,
            container_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              container_end_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_container_end_slot_changes
            ),
            get_container_end_slot_context
          );
        }
      }
      set_dynamic_element_data(
        /*tag*/
        ctx2[1]
      )(svelte_element1, svelte_element_data_1 = get_spread_update(svelte_element1_levels, [
        (!current || dirty & /*containerClasses, className*/
        9 && svelte_element1_class_value !== (svelte_element1_class_value = uniqueClasses(`${/*containerClasses*/
        ctx2[3]}${/*className*/
        ctx2[0] ? ` ${/*className*/
        ctx2[0]}` : ""}`))) && { class: svelte_element1_class_value },
        dirty & /*restProps*/
        32 && /*restProps*/
        ctx2[5]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container_start_slot, local);
      transition_in(wrapper_start_slot, local);
      transition_in(default_slot, local);
      transition_in(wrapper_end_slot, local);
      transition_in(container_end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container_start_slot, local);
      transition_out(wrapper_start_slot, local);
      transition_out(default_slot, local);
      transition_out(wrapper_end_slot, local);
      transition_out(container_end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element1);
      }
      if (container_start_slot)
        container_start_slot.d(detaching);
      if (wrapper_start_slot)
        wrapper_start_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (wrapper_end_slot)
        wrapper_end_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (container_end_slot)
        container_end_slot.d(detaching);
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(154:0) <svelte:element   this={tag}   bind:this={swiperEl}   class={uniqueClasses(`${containerClasses}${className ? ` ${className}` : ''}`)}   {...restProps} >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*tag*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*tag*/
    ctx[1]
  );
  let svelte_element = (
    /*tag*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*tag*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "tag", "wrapperTag", "swiper"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Swiper", slots, ["container-start", "wrapper-start", "default", "wrapper-end", "container-end"]);
  const dispatch = createEventDispatcher();
  let { class: className = void 0 } = $$props;
  let { tag = "div" } = $$props;
  let { wrapperTag = "div" } = $$props;
  let containerClasses = "swiper";
  let breakpointChanged = false;
  let swiperInstance = null;
  let oldPassedParams = null;
  let paramsData;
  let swiperParams;
  let passedParams;
  let restProps;
  let swiperEl = null;
  let prevEl = null;
  let nextEl = null;
  let scrollbarEl = null;
  let paginationEl = null;
  let virtualData = { slides: [] };
  function swiper() {
    return swiperInstance;
  }
  const setVirtualData = (data) => {
    $$invalidate(11, virtualData = data);
    tick().then(() => {
      swiperInstance.$wrapperEl.children(".swiper-slide").each((el) => {
        if (el.onSwiper)
          el.onSwiper(swiperInstance);
      });
      swiperInstance.updateSlides();
      swiperInstance.updateProgress();
      swiperInstance.updateSlidesClasses();
      if (swiperInstance.lazy && swiperInstance.params.lazy.enabled) {
        swiperInstance.lazy.load();
      }
    });
  };
  const calcParams = () => {
    paramsData = getParams($$restProps);
    $$invalidate(4, swiperParams = paramsData.params);
    passedParams = paramsData.passedParams;
    $$invalidate(5, restProps = paramsData.rest);
  };
  calcParams();
  oldPassedParams = passedParams;
  const onBeforeBreakpoint = () => {
    breakpointChanged = true;
  };
  swiperParams.onAny = (event, ...args) => {
    dispatch(event, args);
  };
  Object.assign(swiperParams.on, {
    _beforeBreakpoint: onBeforeBreakpoint,
    _containerClasses(_swiper, classes) {
      $$invalidate(3, containerClasses = classes);
    }
  });
  swiperInstance = new core_default(swiperParams);
  setContext("swiper", swiperInstance);
  if (swiperInstance.virtual && swiperInstance.params.virtual.enabled) {
    const extendWith = {
      cache: false,
      renderExternal: (data) => {
        setVirtualData(data);
        if (swiperParams.virtual && swiperParams.virtual.renderExternal) {
          swiperParams.virtual.renderExternal(data);
        }
      },
      renderExternalUpdate: false
    };
    extend(swiperInstance.params.virtual, extendWith);
    extend(swiperInstance.originalParams.virtual, extendWith);
  }
  onMount(() => {
    if (!swiperEl)
      return;
    mountSwiper(
      {
        el: swiperEl,
        nextEl,
        prevEl,
        paginationEl,
        scrollbarEl,
        swiper: swiperInstance
      },
      swiperParams
    );
    dispatch("swiper", [swiperInstance]);
    if (swiperParams.virtual)
      return;
    swiperInstance.slides.each((el) => {
      if (el.onSwiper)
        el.onSwiper(swiperInstance);
    });
  });
  afterUpdate(() => {
    if (!swiperInstance)
      return;
    calcParams();
    const changedParams = getChangedParams(passedParams, oldPassedParams);
    if ((changedParams.length || breakpointChanged) && swiperInstance && !swiperInstance.destroyed) {
      updateSwiper({
        swiper: swiperInstance,
        passedParams,
        changedParams,
        nextEl,
        prevEl,
        scrollbarEl,
        paginationEl
      });
    }
    breakpointChanged = false;
    oldPassedParams = passedParams;
  });
  onDestroy(() => {
    if (typeof window !== "undefined" && swiperInstance && !swiperInstance.destroyed) {
      swiperInstance.destroy(true, false);
    }
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      prevEl = $$value;
      $$invalidate(7, prevEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      nextEl = $$value;
      $$invalidate(8, nextEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollbarEl = $$value;
      $$invalidate(9, scrollbarEl);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      paginationEl = $$value;
      $$invalidate(10, paginationEl);
    });
  }
  function svelte_element1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      swiperEl = $$value;
      $$invalidate(6, swiperEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("tag" in $$new_props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("wrapperTag" in $$new_props)
      $$invalidate(2, wrapperTag = $$new_props.wrapperTag);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    afterUpdate,
    createEventDispatcher,
    tick,
    setContext,
    Swiper: core_default,
    getParams,
    mountSwiper,
    needsScrollbar,
    needsNavigation,
    needsPagination,
    uniqueClasses,
    extend,
    getChangedParams,
    updateSwiper,
    dispatch,
    className,
    tag,
    wrapperTag,
    containerClasses,
    breakpointChanged,
    swiperInstance,
    oldPassedParams,
    paramsData,
    swiperParams,
    passedParams,
    restProps,
    swiperEl,
    prevEl,
    nextEl,
    scrollbarEl,
    paginationEl,
    virtualData,
    swiper,
    setVirtualData,
    calcParams,
    onBeforeBreakpoint
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("tag" in $$props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("wrapperTag" in $$props)
      $$invalidate(2, wrapperTag = $$new_props.wrapperTag);
    if ("containerClasses" in $$props)
      $$invalidate(3, containerClasses = $$new_props.containerClasses);
    if ("breakpointChanged" in $$props)
      breakpointChanged = $$new_props.breakpointChanged;
    if ("swiperInstance" in $$props)
      swiperInstance = $$new_props.swiperInstance;
    if ("oldPassedParams" in $$props)
      oldPassedParams = $$new_props.oldPassedParams;
    if ("paramsData" in $$props)
      paramsData = $$new_props.paramsData;
    if ("swiperParams" in $$props)
      $$invalidate(4, swiperParams = $$new_props.swiperParams);
    if ("passedParams" in $$props)
      passedParams = $$new_props.passedParams;
    if ("restProps" in $$props)
      $$invalidate(5, restProps = $$new_props.restProps);
    if ("swiperEl" in $$props)
      $$invalidate(6, swiperEl = $$new_props.swiperEl);
    if ("prevEl" in $$props)
      $$invalidate(7, prevEl = $$new_props.prevEl);
    if ("nextEl" in $$props)
      $$invalidate(8, nextEl = $$new_props.nextEl);
    if ("scrollbarEl" in $$props)
      $$invalidate(9, scrollbarEl = $$new_props.scrollbarEl);
    if ("paginationEl" in $$props)
      $$invalidate(10, paginationEl = $$new_props.paginationEl);
    if ("virtualData" in $$props)
      $$invalidate(11, virtualData = $$new_props.virtualData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    tag,
    wrapperTag,
    containerClasses,
    swiperParams,
    restProps,
    swiperEl,
    prevEl,
    nextEl,
    scrollbarEl,
    paginationEl,
    virtualData,
    swiper,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    div_binding,
    div_binding_1,
    svelte_element1_binding
  ];
}
var Swiper_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      class: 0,
      tag: 1,
      wrapperTag: 2,
      swiper: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Swiper_1",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperTag() {
    throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperTag(value) {
    throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swiper() {
    return this.$$.ctx[12];
  }
  set swiper(value) {
    throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var swiper_default = Swiper_1;

// node_modules/swiper/svelte/swiper-slide.svelte
var file2 = "node_modules\\swiper\\svelte\\swiper-slide.svelte";
var get_default_slot_changes_1 = (dirty) => ({ data: dirty & /*slideData*/
32 });
var get_default_slot_context_1 = (ctx) => ({ data: (
  /*slideData*/
  ctx[5]
) });
var get_default_slot_changes2 = (dirty) => ({ data: dirty & /*slideData*/
32 });
var get_default_slot_context2 = (ctx) => ({ data: (
  /*slideData*/
  ctx[5]
) });
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context_1
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slideData*/
        160)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(92:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let div_data_swiper_zoom_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-swiper-zoom": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "swiper-zoom-container");
      attr_dev(div, "data-swiper-zoom", div_data_swiper_zoom_value = typeof /*zoom*/
      ctx[0] === "number" ? (
        /*zoom*/
        ctx[0]
      ) : void 0);
      add_location(div, file2, 85, 4, 2126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, slideData*/
        160)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
      if (!current || dirty & /*zoom*/
      1 && div_data_swiper_zoom_value !== (div_data_swiper_zoom_value = typeof /*zoom*/
      ctx2[0] === "number" ? (
        /*zoom*/
        ctx2[0]
      ) : void 0)) {
        attr_dev(div, "data-swiper-zoom", div_data_swiper_zoom_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(85:2) {#if zoom}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*zoom*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    {
      class: div_class_value = uniqueClasses(`${/*slideClasses*/
      ctx[3]}${/*className*/
      ctx[2] ? ` ${/*className*/
      ctx[2]}` : ""}`)
    },
    {
      "data-swiper-slide-index": (
        /*virtualIndex*/
        ctx[1]
      )
    },
    /*$$restProps*/
    ctx[6]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-swiper-slide-index": true
      });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 78, 0, 1942);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[9](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*slideClasses, className*/
        12 && div_class_value !== (div_class_value = uniqueClasses(`${/*slideClasses*/
        ctx2[3]}${/*className*/
        ctx2[2] ? ` ${/*className*/
        ctx2[2]}` : ""}`))) && { class: div_class_value },
        (!current || dirty & /*virtualIndex*/
        2) && {
          "data-swiper-slide-index": (
            /*virtualIndex*/
            ctx2[1]
          )
        },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let slideData;
  const omit_props_names = ["zoom", "virtualIndex", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Swiper_slide", slots, ["default"]);
  let { zoom = void 0 } = $$props;
  let { virtualIndex = void 0 } = $$props;
  let { class: className = void 0 } = $$props;
  let slideEl = null;
  let slideClasses = "swiper-slide";
  let swiper = getContext("swiper");
  let eventAttached = false;
  const updateClasses = (_, el, classNames) => {
    if (el === slideEl) {
      $$invalidate(3, slideClasses = classNames);
    }
  };
  const attachEvent = () => {
    if (!swiper || eventAttached)
      return;
    swiper.on("_slideClass", updateClasses);
    eventAttached = true;
  };
  const detachEvent = () => {
    if (!swiper)
      return;
    swiper.off("_slideClass", updateClasses);
    eventAttached = false;
  };
  onMount(() => {
    if (typeof virtualIndex === "undefined")
      return;
    $$invalidate(
      4,
      slideEl.onSwiper = (_swiper) => {
        swiper = _swiper;
        attachEvent();
      },
      slideEl
    );
    attachEvent();
  });
  afterUpdate(() => {
    if (!slideEl || !swiper)
      return;
    if (swiper.destroyed) {
      if (slideClasses !== "swiper-slide") {
        $$invalidate(3, slideClasses = "swiper-slide");
      }
      return;
    }
    attachEvent();
  });
  beforeUpdate(() => {
    attachEvent();
  });
  onDestroy(() => {
    if (!swiper)
      return;
    detachEvent();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      slideEl = $$value;
      $$invalidate(4, slideEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("zoom" in $$new_props)
      $$invalidate(0, zoom = $$new_props.zoom);
    if ("virtualIndex" in $$new_props)
      $$invalidate(1, virtualIndex = $$new_props.virtualIndex);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    beforeUpdate,
    afterUpdate,
    setContext,
    getContext,
    uniqueClasses,
    zoom,
    virtualIndex,
    className,
    slideEl,
    slideClasses,
    swiper,
    eventAttached,
    updateClasses,
    attachEvent,
    detachEvent,
    slideData
  });
  $$self.$inject_state = ($$new_props) => {
    if ("zoom" in $$props)
      $$invalidate(0, zoom = $$new_props.zoom);
    if ("virtualIndex" in $$props)
      $$invalidate(1, virtualIndex = $$new_props.virtualIndex);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("slideEl" in $$props)
      $$invalidate(4, slideEl = $$new_props.slideEl);
    if ("slideClasses" in $$props)
      $$invalidate(3, slideClasses = $$new_props.slideClasses);
    if ("swiper" in $$props)
      swiper = $$new_props.swiper;
    if ("eventAttached" in $$props)
      eventAttached = $$new_props.eventAttached;
    if ("slideData" in $$props)
      $$invalidate(5, slideData = $$new_props.slideData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*slideClasses*/
    8) {
      $:
        $$invalidate(5, slideData = {
          isActive: slideClasses.indexOf("swiper-slide-active") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-active") >= 0,
          isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
          isDuplicate: slideClasses.indexOf("swiper-slide-duplicate") >= 0,
          isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-prev") >= 0,
          isNext: slideClasses.indexOf("swiper-slide-next") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-next") >= 0
        });
    }
  };
  return [
    zoom,
    virtualIndex,
    className,
    slideClasses,
    slideEl,
    slideData,
    $$restProps,
    $$scope,
    slots,
    div_binding
  ];
}
var Swiper_slide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { zoom: 0, virtualIndex: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Swiper_slide",
      options,
      id: create_fragment2.name
    });
  }
  get zoom() {
    throw new Error("<Swiper_slide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoom(value) {
    throw new Error("<Swiper_slide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get virtualIndex() {
    throw new Error("<Swiper_slide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set virtualIndex(value) {
    throw new Error("<Swiper_slide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Swiper_slide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Swiper_slide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var swiper_slide_default = Swiper_slide;
export {
  swiper_default as Swiper,
  swiper_slide_default as SwiperSlide
};
//# sourceMappingURL=swiper_svelte.js.map
